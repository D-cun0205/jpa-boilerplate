### 연관관계 주인 설정

```
- 테이블에서 외래 키를 관리하는 기준으로 해당 엔티티가 주인 상대 엔티티가 mappedBy 로 주인을 설정하여 사용
```

### 양방향 연관관계 편의 메서드

```
- 외래 키를 관리하는 주인 엔티티에서 상대 엔티티를 set 할 때 set 메서드에서 상대 엔티티로 부터 자신(this)을 넣어주는 로직 추가
- clean, flush 가 발생하지 않은 기준 상대 엔티티로 부터 조회할 때 조회가 안되거나 문제가 발생할 수 있음
```

### 다대다 연관관계(사용 금지)

```
- 다대다 연관관계를 사용하면 A와 B의 시퀀스를 가지는 중간 테이블이 생성되는데 운영레벨에서 사용시 해당 테이블에 추가 필드가 필요한 경우가 많음
  이런 경우 필드를 추가하여 사용하면 큰 문제가 발생될 수 있기 때문에 아래와 같이 해결
- 중개 역할 테이블을 생성하여 A : Proxy : B A와 Proxy에 1대N,N대1 B와 Proxy에 1대N,N대1 구조로 풀어서 사용
```

### 상속관계 매핑

```
- @Inheritance(strategy=InheritanceType.선택)
- TABLE_PER_CLASS: 구현 클래스마다 테이블 전략(사용 금지)
  - 말 그대로 조인이 없고 각자의 테이블로 움직이기 때문에 해당 테이블을 통한 계산이 필요하거나 어떠한 통합이 필요한 경우 문제가 생길 가능성이 상당히 높음
- SINGLE_TABLE: 단일 테이블 전략(O)
  - 비지니스적으로 엄청 단순하거나 데이터가 많이 생기지 않을 거 같은 케이스에 적용하기 좋음
- JOINED: 조인 전략(O, 권장)
```

### 엔티티에 항상 들어가는 공통 값을 위한 어노테이션

```
- @MappedSuperclass
- 예를 들면 생성일, 생성자, 수정일, 수정자 ?
- 새로운 클래스를 생성, @Entity 필요 없음, @Column 사용 가능
- 해당 클래스가 필요한 곳에서 상속 적용
- 해당 클래스를 직접 생성해서 사용할 일이 없으므로 추상(abstract) 선언 권장
```

### JPA 타입 비교

```
- 타입 비교를 진행할 때 == 비교는 정확한 타입이 아닌 경우 false 를 리턴한다 상속 클래스 또한 허용안됨
- 비지니스 로직에서 특정 메서드에 객체 두 개를 받아 타입을 비교하는 경우 실제 객체인지 프록시로 받은 객체인지 더 확인이 어려움
- 그러므로 타입 비교가 필요한 경우 instanceOf 를 사용 권장
```

### 프록시

```
- 프록시 객체는 객체 선언이 아닌 실제 사용할 때 DB 에 데이터 호출이 일어남
```

### 즉시 로딩, 지연 로딩

```
- 즉시 로딩은 연관관계가 있는 A, B 엔티티에 대해 A를 호출하면 B까지 조인으로 한번에 조회
- 지연 로딩은 연관관계가 있는 A, B 엔티티에 대해 A를 호출해도 B를 조회하지 않고 B를 사용하는 시점에 조회
- 처음 엔티티 설계 및 연관관계를 설정할 때 모든 연관관계에 대해 지연로딩을 기본으로 설정하고
  개발 및 운영하면서 A 엔티티 조회시 B가 같이 사용되는 케이스 많은 경우 지연 로딩을 즉시 로딩으로 변경하여 사용하는 것을 권장
- @OneToMany, @ManyToMany 는 기본 설정이 지연 로딩이므로 별도로 설정할 필요 없고
  @ManyToOne, @OneToOne 은 기본 설정이 즉시 로딩이므로 fetch = FetchType.Lazy 설정을 꼭 해줄 것

* 중요
- N+1 문제
    - 연관관계에 즉시로딩 설정 되어있는 엔티티를 JPQL 로 호출시
        - 예시로 Member 를 JPQL 로 조회할 때 Team 엔티티가 즉시로딩 설정되어 있으면 값을 받아야되기 때문에
          Member 가 1명 또는 N명이라면 1~N 명의 멤버마다 Team 값을 가지기 위해 1~N 값을 얻기 위한 쿼리가 날라감
          JPQL 로 조회한 멤버가 10만명이면 + 10만번의 쿼리가 날라가는셈
    - 해결 방법
        - 먼저 기본 설정이 즉시 로딩인 어노테이션에 지연 로딩으로 바름(실무 경험 넘치는 김영한 엔지니어 왈)
        - 지연 로딩이지만 꼭 필요하다 할 때 FetchJoin 설정
            - N + 1 에 대한 문제를 먼저 인지하여 해결하기 위한 방법으로 한번에 Member + Team 을 조인하여 가져옴
            - JPQL 안에 fetch 예약어 사용
```
    
### cascade

```
- Parent, Child 엔티티가 1대다 연관관계 매핑인 경우 부모를 persist 할 때 child 도 같이 저장 또는 저장/삭제를 지원
- 1대다의 구조에서 다 를 제어하는 엔티티가 딱 하나인 경우(단일 소유자)에 사용 가능
- 1 을 삭제하게되면 N 도 관계가 모두 삭제되는 쿼리가 호출
```

### 고아 객체

```
- orphanRemoval = true
- 1대다 구조에서 1 엔티티안에 N 중 한명과 관계가 끊어지면 delete 쿼리가 호출
- 특정 엔티티가 개인 소유할 때만 사용, 삭제 쿼리가 호출되므로 주의해서 사용
``` 

### cascade + 고아 객체

```
- 사용해도 되는 상황에서 사용할 경우에는 자식 라이프싸이클을 부모가 관리할 수 있는 장점이 있다
```

### 임베디드

```
- @Embeddable, @Embedded
    - 객체 지향 스럽게 객체를 사용하는 방법으로 주소를 사용할 경우 필요한 zipcode, street, city
      기간 설정에 필요한 startDate, endDate 이런 고정적인 필드들을 별도의 클래스로 만들어 @Embeddable 붙이고
      해당 객체를 사용하고 싶은 엔티티에서 필드를 생성하고 @Embedded 를 붙여서 사용 가능
    - 기본 생성자 필수
- @AttributeOverrides, @AttributeOverride
    - 하나의 엔티티에서 주소클래스가 2개 필요한 경우에 사용할 수 있다
    - 2개의 주소 클래스가 컬럼명이 중복되지 않게 위 어노테이션 설정 안에 컬럼 속성에 @Column 을 사용하여
      다른 필드로 적용되도록 설정 필요
* 중요
- 임베디드 값 타입 복사
    - 이런 상황은 흔하지는 않지만 두 명의 멤버를 선언하고 저장할 때 임베디드로 생성한 주소가 동일하여 같이 저장한 경우
        - new Address, new Member(address): 멤버A, new Member(address): 멤버B
          위 상황에서 멤버 A의 주소를 바꾸고 싶다고 멤버A.getAddress.set필드(값) 으로 update 가 될 경우
          new Address 를 포함한 멤버A, 멤버B 혹은 더 많은 멤버를 연결했을 때 모든 멤버들의 값이 바뀐다
          꼭 필요한 경우 서로 다른 멤버에 다른 address 를 복사하여 설정하고 저장 및 수정해야한다
        - 제일 좋은 방법으로는 생성자에서만 데이터를 설정할 수 있고 수정자를 허용하지 않은 방법을 적용
```

### equals

```
- equals 의 기본 타입 비교는 == 이기 때문에 엔티티는 equals 를 생성해야하는데
  Intellij 를 사용하는 경우 기본적으로 제공해주는 equals, hashcode 자동 생성만 사용해도 문제되지 않으니
  생성해서 사용할 것
```

### 값 타입 컬렉션

```
- @ElementCollection, @CollectionTable(name, joincolumn 설정 필요)
    - 2개의 어노테이션을 생성하여 값 타입 컬렉션을 사용할 수 있다
    - Member 에 매핑된 멤버가 좋아하는 과일 리스트가 있는 경우 위 두 어노테이션을 상세히 적용하면
      member_id 와, 과일 컬럼이 포함된 테이블이 생성된다
    - 지연 로딩으로 적용되며 영속성 전이 + 고아 객체 제거 기능을 필수로 가진다
```

### 엔티티에는 가급적 Setter 사용 금지

### 리스트 타입 필드 선언과 동시에 초기화 

```
- null 을 피할 수 있다
- JPA 메커니즘에 의하면 OneToMany 와 같은 리스트 타입을 생성할 때 JPA 에서 구현한 Wrapper 클래스로 해당 클래스를 감싼다
  이를 getClass 로 출력해보면 ArrayList 가 아닌 PerststentBag 또는 다른 이름이 출력되는데 이는 JPA 에서
  값이 변경 같은 여러 변경사항을 감지하여 추적하기 위한 용도로 사용되기 때문이다
  그렇기 때문에 뒤 늦은 List 초기화는 문제가되어 JPA 메커니즘대로 작동하지 않을 수 있다
```

### @Transactional

```
- 데이터 수정 및 읽기가 일어나는 곳에는 해당 어노테이션을 사용한다
- 읽기의 경우 속성으로 readOnly = true 를 사용하면 더티 체킹 같은 불필요한 작업을 줄여 성능에 약간의 이점을 가질 수 있다
- @Service 어노테이션을 사용하는 클래스에서 주로 JPA CRUD 가 발생하므로 여기에 해당 어노테이션을 적용한다
```

### 도메인 모델 패턴

```
예제 코드에서 주문 서비스의 주문과 주문 취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다
서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다
이처럼 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 도메인 모델 패턴이라한다
반대로 기존에 서비스 계층에서 비지니스 로직을 모두 작성하여 사용하는 방식을 트랜잭션 스크립트 패턴이라 한다
좋고 나쁘고의 차이는 없고 프로젝트에 따라 사용하거나 같이 적용하는 경우도 있다
```

### 좋은 테스트

```
DB, 스프링도 엮지 않고 메서드에 대한 단위 테스트를 만들어서 진행하는게 좋음
JPA 를 사용하게 되면 위에서 언급한 도메인 모델 패턴 방식의 개발을 많이 하게되는데
테스트 작성시 엔티티 내부에 비지니스 로직(CRUD)에 대한 단위 테스트를 작성하길 권장한다고 한다
```

### 변경 감지와 병합

```
우선 merge 는 사용하지 말 것
merge 메커니즘은 전달 받은 객체에 있는 id 필드로 DB 를 조회해서 영속 상태의 엔티티를 만들고
전달 받은 객체에 모든 필드 들의 값으로 교체하는데 이 때 null 이 있는 경우 null 로 업데이트 될 수 있다

변경 감지 == dirty checking
준영속 엔티티에 대해 setter 로 값을 변경할 경우 실제로 업데이트 쿼리는 호출되지 않는다
```

### Entity 주의 사항

#### @JsonIgnore

```
양방향 연관관계가 설정된 엔티티가 있는데 해당 엔티티를 응답 객체로 노출한 경우
A 에서 json 으로 변환하다가 B 를 발견하고 B 객체로 가서 json 으로 다시 A 로 무한 루프
결국 한쪽을 @JsonIgnore 로 해결할 수 있지만 엔티티는 애초에 응답에 노출하지 않아야 한다
```

#### toString 사용시 주의 사항

```
stackOverFlow 예외가 발생할 수 있는데 이유는 연관관계 매핑시 양방향 연관관계인 경우
toString 에서 서로를 계속 참조하기 때문에
```

#### API 프로젝트 개발할 때 엔티티를 절대로 파라미터나 응답 객체로 사용하지 말 것

```
엔티티를 노출하고 있는데 엔티티의 필드명을 바꾸게 되면 API 명세가 바뀌게 될 수 있다

예를 들어서 Member 엔티티를 내보내려고 할 때 사용자가 원하는 정보는 단순히 Member 정보인경우
연관관계에 있는 필드가 널 값으로 포함되어 출력된다
```

### 조회 성능 최적화

```
Entity to DTO
1 + N to fetch = lazy
일반적인 join fetch vs 레파지토리 DTO 직접 반환

쿼리 방식 선택 권장 순서
1.Entity to DTO
2.필요한 경우 fetch join 추가
3.DTO 직접 조회
4.JPA 에서 제공하는 네이티브 SQL, Spring JDBC Template SQL 직접 사용


-------- 최종

엔티티 조회 방식 접근
    페치 조인으로 쿼리 수 최적화
    컬레션 최적화
        페이징 필요한 경우 hibernate.default_batch_fetch_size, @BatchSize
        페이징 X 경우 페치 조인 사용
엔티티 조회 방식으로 해결이 안될 경우 DTO 조회
DTO 조회로 해결이 안될 경우 NativeSQL, Spring JdbcTemplate
```

### distinct

```
중요: 컬렉션 페치 조인을 사용하는 경우 페이징이 불가능함

데이터 베이스 기준 1대N 조인이 있으면 데이터베이스가 조인할 때 당연히 row 수가 증가 되는데
엔티티가 증가되는건 우리가 원하는 결과가 아니며 이를 위해 distinct 를 추가하면
같은 엔티티가 조회될 경우 애플리케이션에서 중복을 제거한 후 결과 값을 리턴 해준다

Starting with Hibernate 6, distinct is always passed to the SQL query and the flag 
QueryHints#HINT_PASS_DISTINCT_THROUGH has been removed.

강의에서 확인했을 당시 hibernate 버전이 6 아래였고 중복되는 데이터를 막기 위해
JPQL 안에 distinct 를 사용했으나 이 후 버전에 대해서는 항상 자동 적용된다
```

### 1대N 페치 조인시 페이징

```
위 distinct 를 사용하게 된 이유 처럼 일반적으로 fetch 조인을 진행한 경우
row 수가 증가되며 우리가 원하는 데이터가 아니고 distinct 를 적용해서 중복을 제거하는데
setFirstResult(), setMaxResults() 를 사용하면 DB에 이를 호출할 수 없어서

WARN: firstResult/maxResults specified with collection fetch; applying in memory
위 와 같이 메시지가 출력되고 메모리에서 실행을 시도하며 이게 데이터가 많은 경우
큰 문제가 발생할 수 있으므로 1대N 에 fetch 조인을 사용한 경우 페이징 메서드를 호출하는걸 권장하지 않는다
```

### 1대N 페치 조인시 페이징 해결 방안 

```
우선 문제가 발생하는 건 ToMany 에서 발생하므로 ToOne 에 대해서는 동일하게 fetch 조인을 JPQL 로 세팅한다
hibernate.default_batch_fetch_size: 숫자 또는 @BatchSize(size = 숫자) 설정
이 후 사용할 때 lazy 설정으로 그래프 탐색 시 N+1 문제가 발생하는게 아니며
위 옵션들은 SQL 에서 in 절을 생성해주고 숫자는 하나의 in 절 쿼리에 집어넣을 엔티티 식별 값(id) 개수를 의미한다
예시로 해당 프로젝트에서 Order - OrderItem - Item 의 1:N:M 의 연관 관계가 있을 때 위 설정 값을 적용하고
쿼리는 (Order)1, (OrderItem)1, (Item)1 총 3건이 나간다
물론 위 기능의 숫자 내에 데이터가 존재하는 경우 그 이상이면 입력한 숫자로 나눈 값 + 1 수만큼 쿼리

참고로 hibernate.default_batch_fetch_size 설정은 application.properties(yml) 에 설정하면 되고
@BatchSize 는 ToMany 의 경우 해당 엔티티의 연관관계 필드에다가 적용해주고
ToOne 의 경우는 One 의 대상 클래스의 @Entity 선언되어있는 곳에 선언하여 적용해야한다

설정 값은 1 ~ 1000(Max) 인데 100 500 1000 사이로 설정하고 너무 작게만 설정하지 않으면 크게 고민할필요가 없다
```

### 1 대 N 대 N 페치 조인은 사용 금지

```
데이터가 부정합할 수 있고 심지어 Hibernate 에서도 사용은 가능하나 둘 이상의 fetch 조인에 대해
경고 메시지를 출력하니 다른 방법으로 풀어야 한다
```

### 캐시를 사용하는 경우

```
엔티티는 영속성 컨텍스트에서 관리되는데 엔티티를 캐시에 등록할 경우 데이터가 꼬일 수 있으니
캐시를 사용할 때도 DTO 를 통해서 저장하는 방식으로 사용해야 한다
```

### OSIV(OpenSessionInView, Spring Boot 설정 파일에서는 OpenInView 명칭 사용)

```
영속성 컨텍스트가 DB 커넥션을 끊고 관리를 멈추는 시점을 정하는 것
true 의 경우 요청 시점 부터 클라이언트에게 응답을 하기 직전까지 유지
false 의 경우 SpringBoot 기준 @Transaction 선언 지점까지만 유지
```

### Spring Data JPA 사용할 때 쿼리 호출하는 방법

```
1.(가장 먼저 사용 고려)단순한 쿼리 호출인 경우 파라미터가 1~2개 정도 들어갈 때 메서드 이름으로 쿼리 생성 사용
2.(사용 권장 안함)엔티티에 @NamedQuery 사용해서 쿼리 작성하는 방법
3.(1번에서 한계가 있을 때 사용)레파지토리 메서드에 쿼리 정의하기 
```