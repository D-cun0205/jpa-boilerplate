### toString, JSON, lombok toString 사용시 주의 사항

```
- stackOverFlow 예외가 발생할 수 있는데 이유는 연관관계 매핑시 양방향 연관관계인 경우
  - toString 에서 서로를 계속 참조하기 때문에
- JSON 사용시 문제가 발생하는 경우는 컨트롤러에서 엔티티 객체를 응답으로 전달할 때
  - JSON 으로 변환하면서 위 와 같은 구조로 에러가 발생할 수 있음
    그러므로 엔티티는 절대 반환에 사용하지말고 DTO 로 구분하여 반환하는 것을 권장
```

### 연관관계 주인 설정

```
- 테이블에서 외래 키를 관리하는 기준으로 해당 엔티티가 주인 상대 엔티티가 mappedBy 로 주인을 설정하여 사용
```

### 양방향 연관관계 편의 메서드

```
- 외래 키를 관리하는 주인 엔티티에서 상대 엔티티를 set 할 때 set 메서드에서 상대 엔티티로 부터 자신(this)을 넣어주는 로직 추가
- clean, flush 가 발생하지 않은 기준 상대 엔티티로 부터 조회할 때 조회가 안되거나 문제가 발생할 수 있음
```

### 다대다 연관관계(사용 금지)

```
- 다대다 연관관계를 사용하면 A와 B의 시퀀스를 가지는 중간 테이블이 생성되는데 운영레벨에서 사용시 해당 테이블에 추가 필드가 필요한 경우가 많음
  이런 경우 필드를 추가하여 사용하면 큰 문제가 발생될 수 있기 때문에 아래와 같이 해결
- 중개 역할 테이블을 생성하여 A : Proxy : B A와 Proxy에 1대N,N대1 B와 Proxy에 1대N,N대1 구조로 풀어서 사용
```

### 상속관계 매핑

```
- @Inheritance(strategy=InheritanceType.선택)
- TABLE_PER_CLASS: 구현 클래스마다 테이블 전략(사용 금지)
  - 말 그대로 조인이 없고 각자의 테이블로 움직이기 때문에 해당 테이블을 통한 계산이 필요하거나 어떠한 통합이 필요한 경우 문제가 생길 가능성이 상당히 높음
- SINGLE_TABLE: 단일 테이블 전략(O)
  - 비지니스적으로 엄청 단순하거나 데이터가 많이 생기지 않을 거 같은 케이스에 적용하기 좋음
- JOINED: 조인 전략(O, 권장)
```

### 엔티티에 항상 들어가는 공통 값을 위한 어노테이션

```
- @MappedSuperclass
- 예를 들면 생성일, 생성자, 수정일, 수정자 ?
- 새로운 클래스를 생성, @Entity 필요 없음, @Column 사용 가능
- 해당 클래스가 필요한 곳에서 상속 적용
- 해당 클래스를 직접 생성해서 사용할 일이 없으므로 추상(abstract) 선언 권장
```

### JPA 타입 비교

```
- 타입 비교를 진행할 때 == 비교는 정확한 타입이 아닌 경우 false 를 리턴한다 상속 클래스 또한 허용안됨
- 비지니스 로직에서 특정 메서드에 객체 두 개를 받아 타입을 비교하는 경우 실제 객체인지 프록시로 받은 객체인지 더 확인이 어려움
- 그러므로 타입 비교가 필요한 경우 instanceOf 를 사용 권장
```

### 프록시

```
- 프록시 객체는 객체 선언이 아닌 실제 사용할 때 DB 에 데이터 호출이 일어남
```

### 즉시 로딩, 지연 로딩

```
- 즉시 로딩은 연관관계가 있는 A, B 엔티티에 대해 A를 호출하면 B까지 조인으로 한번에 조회
- 지연 로딩은 연관관계가 있는 A, B 엔티티에 대해 A를 호출해도 B를 조회하지 않고 B를 사용하는 시점에 조회
- 처음 엔티티 설계 및 연관관계를 설정할 때 모든 연관관계에 대해 지연로딩을 기본으로 설정하고
  개발 및 운영하면서 A 엔티티 조회시 B가 같이 사용되는 케이스 많은 경우 지연 로딩을 즉시 로딩으로 변경하여 사용하는 것을 권장
- @OneToMany, @ManyToMany 는 기본 설정이 지연 로딩이므로 별도로 설정할 필요 없고
  @ManyToOne, @OneToOne 은 기본 설정이 즉시 로딩이므로 fetch = FetchType.Lazy 설정을 꼭 해줄 것

* 중요
- N+1 문제
    - 연관관계에 즉시로딩 설정 되어있는 엔티티를 JPQL 로 호출시
        - 예시로 Member 를 JPQL 로 조회할 때 Team 엔티티가 즉시로딩 설정되어 있으면 값을 받아야되기 때문에
          Member 가 1명 또는 N명이라면 1~N 명의 멤버마다 Team 값을 가지기 위해 1~N 값을 얻기 위한 쿼리가 날라감
          JPQL 로 조회한 멤버가 10만명이면 + 10만번의 쿼리가 날라가는셈
    - 해결 방법
        - 먼저 기본 설정이 즉시 로딩인 어노테이션에 지연 로딩으로 바름(실무 경험 넘치는 김영한 엔지니어 왈)
        - 지연 로딩이지만 꼭 필요하다 할 때 FetchJoin 설정
            - N + 1 에 대한 문제를 먼저 인지하여 해결하기 위한 방법으로 한번에 Member + Team 을 조인하여 가져옴
            - JPQL 안에 fetch 예약어 사용
```
    
### cascade

```
- Parent, Child 엔티티가 1대다 연관관계 매핑인 경우 부모를 persist 할 때 child 도 같이 저장 또는 저장/삭제를 지원
- 1대다의 구조에서 다 를 제어하는 엔티티가 딱 하나인 경우(단일 소유자)에 사용 가능
- 1 을 삭제하게되면 N 도 관계가 모두 삭제되는 쿼리가 호출
```

### 고아 객체

```
- orphanRemoval = true
- 1대다 구조에서 1 엔티티안에 N 중 한명과 관계가 끊어지면 delete 쿼리가 호출
- 특정 엔티티가 개인 소유할 때만 사용, 삭제 쿼리가 호출되므로 주의해서 사용
``` 

### cascade + 고아 객체

```
- 사용해도 되는 상황에서 사용할 경우에는 자식 라이프싸이클을 부모가 관리할 수 있는 장점이 있다
```

### 임베디드

```
- @Embeddable, @Embedded
    - 객체 지향 스럽게 객체를 사용하는 방법으로 주소를 사용할 경우 필요한 zipcode, street, city
      기간 설정에 필요한 startDate, endDate 이런 고정적인 필드들을 별도의 클래스로 만들어 @Embeddable 붙이고
      해당 객체를 사용하고 싶은 엔티티에서 필드를 생성하고 @Embedded 를 붙여서 사용 가능
    - 기본 생성자 필수
- @AttributeOverrides, @AttributeOverride
    - 하나의 엔티티에서 주소클래스가 2개 필요한 경우에 사용할 수 있다
    - 2개의 주소 클래스가 컬럼명이 중복되지 않게 위 어노테이션 설정 안에 컬럼 속성에 @Column 을 사용하여
      다른 필드로 적용되도록 설정 필요
* 중요
- 임베디드 값 타입 복사
    - 이런 상황은 흔하지는 않지만 두 명의 멤버를 선언하고 저장할 때 임베디드로 생성한 주소가 동일하여 같이 저장한 경우
        - new Address, new Member(address): 멤버A, new Member(address): 멤버B
          위 상황에서 멤버 A의 주소를 바꾸고 싶다고 멤버A.getAddress.set필드(값) 으로 update 가 될 경우
          new Address 를 포함한 멤버A, 멤버B 혹은 더 많은 멤버를 연결했을 때 모든 멤버들의 값이 바뀐다
          꼭 필요한 경우 서로 다른 멤버에 다른 address 를 복사하여 설정하고 저장 및 수정해야한다
        - 제일 좋은 방법으로는 생성자에서만 데이터를 설정할 수 있고 수정자를 허용하지 않은 방법을 적용
```

### equals

```
- equals 의 기본 타입 비교는 == 이기 때문에 엔티티는 equals 를 생성해야하는데
  Intellij 를 사용하는 경우 기본적으로 제공해주는 equals, hashcode 자동 생성만 사용해도 문제되지 않으니
  생성해서 사용할 것
```

### 값 타입 컬렉션

```
- @ElementCollection, @CollectionTable(name, joincolumn 설정 필요)
    - 2개의 어노테이션을 생성하여 값 타입 컬렉션을 사용할 수 있다
    - Member 에 매핑된 멤버가 좋아하는 과일 리스트가 있는 경우 위 두 어노테이션을 상세히 적용하면
      member_id 와, 과일 컬럼이 포함된 테이블이 생성된다
    - 지연 로딩으로 적용되며 영속성 전이 + 고아 객체 제거 기능을 필수로 가진다
```

### 엔티티에는 가급적 Setter 사용 금지

### 리스트 타입 필드 선언과 동시에 초기화 

```
- null 을 피할 수 있다
- JPA 메커니즘에 의하면 OneToMany 와 같은 리스트 타입을 생성할 때 JPA 에서 구현한 Wrapper 클래스로 해당 클래스를 감싼다
  이를 getClass 로 출력해보면 ArrayList 가 아닌 PerststentBag 또는 다른 이름이 출력되는데 이는 JPA 에서
  값이 변경 같은 여러 변경사항을 감지하여 추적하기 위한 용도로 사용되기 때문이다
  그렇기 때문에 뒤 늦은 List 초기화는 문제가되어 JPA 메커니즘대로 작동하지 않을 수 있다
```

### @Transactional

```
- 데이터 수정 및 읽기가 일어나는 곳에는 해당 어노테이션을 사용한다
- 읽기의 경우 속성으로 readOnly = true 를 사용하면 더티 체킹 같은 불필요한 작업을 줄여 성능에 약간의 이점을 가질 수 있다
- @Service 어노테이션을 사용하는 클래스에서 주로 JPA CRUD 가 발생하므로 여기에 해당 어노테이션을 적용한다
```

### 도메인 모델 패턴

```
예제 코드에서 주문 서비스의 주문과 주문 취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다
서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다
이처럼 엔티티가 비즈니스 로직을 가지고 객체 지향의 특성을 적극 활용하는 것을 도메인 모델 패턴이라한다
반대로 기존에 서비스 계층에서 비지니스 로직을 모두 작성하여 사용하는 방식을 트랜잭션 스크립트 패턴이라 한다
좋고 나쁘고의 차이는 없고 프로젝트에 따라 사용하거나 같이 적용하는 경우도 있다
```

### 좋은 테스트

```
DB, 스프링도 엮지 않고 메서드에 대한 단위 테스트를 만들어서 진행하는게 좋음
JPA 를 사용하게 되면 위에서 언급한 도메인 모델 패턴 방식의 개발을 많이 하게되는데
테스트 작성시 엔티티 내부에 비지니스 로직(CRUD)에 대한 단위 테스트를 작성하길 권장한다고 한다
```

### 변경 감지와 병합

```
우선 merge 는 사용하지 말 것
merge 메커니즘은 전달 받은 객체에 있는 id 필드로 DB 를 조회해서 영속 상태의 엔티티를 만들고
전달 받은 객체에 모든 필드 들의 값으로 교체하는데 이 때 null 이 있는 경우 null 로 업데이트 될 수 있다

변경 감지 == dirty checking
준영속 엔티티에 대해 setter 로 값을 변경할 경우 실제로 업데이트 쿼리는 호출되지 않는다
```